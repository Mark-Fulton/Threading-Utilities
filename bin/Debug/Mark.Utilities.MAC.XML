<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Mark.Utilities.MAC</name>
    </assembly>
    <members>
        <member name="T:ThreadingUtilities.BoundChannel`1">
            <summary>
            Bound channel.
            
            This is an editation of the Channel class.
            This requires you to enter a limit of how many items you would like to have in the queue
            This uses a Semaphore to add a limit to the class, the semaphore adds a thread save count to make sure that it does not get past the limit.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ThreadingUtilities.Channel`1" -->
        <member name="M:ThreadingUtilities.Channel`1.PutObject(`0)">
            <summary>
            Puts the object.
            
            This accepts the type of object that you have declared in the use of the channel.
            this then once the object has been given to the Queue it gives the semaphore a token to acknowledge that there is work to do. 
            </summary>
            <param name="Object">Object.</param>
        </member>
        <member name="M:ThreadingUtilities.Channel`1.TakeObject">
            <summary>
            Takes the object.
            
            This is for an object that you want to recieve in the Queue
            Once in the method we acquire a token so we dont trick any other threads trying to get an object
            Then in a thread safe area we dequeue the queue. and return the object wanted.
            </summary>
            <returns>The object.</returns>
        </member>
        <member name="M:ThreadingUtilities.Channel`1.Poll(System.Int32,`0@)">
            <summary>
            Poll the specified TimeToWait and result.
            
            What this class does is it keeps track of the time that is required to dequeue an object
            What this means is that if the item is under the required time that the user inputs in MS it will return true
            If it does not however it will return false
            </summary>
            <param name="TimeToWait">Time to wait.</param>
            <param name="result">Result.</param>
        </member>
        <member name="M:ThreadingUtilities.BoundChannel`1.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.BoundChannel`1"/> class.
            
            This backs the Channel class and allows the functionality for the Limit.
            This is in a Ulong and gets ported into a Semaphore and allows this functionallity.
            </summary>
            <param name="Limit">Limit.</param>
        </member>
        <member name="M:ThreadingUtilities.BoundChannel`1.PutObject(`0)">
            <summary>
            Puts the object.
            
            This accepts the type of object that you have declared in the use of the channel.
            this then once the object has been given to the Queue it gives the semaphore a token to acknowledge that there is
            work to do.
            
            This added code for acquiring the token will fill out the requirements of the bound channel.
            This will not allow you to put any objects in the queue without a token being in the semaphore
            </summary>
            <param name="Object">Object.</param>
        </member>
        <member name="M:ThreadingUtilities.BoundChannel`1.TakeObject">
            <summary>
            Takes the object.
            
            This is for an object that you want to recieve in the Queue
            Once in the method we acquire a token so we dont trick any other threads trying to get an object
            Then in a thread safe area we dequeue the queue. and return the object wanted.
            
            This added code will allow you to when you remove an item from the queue it will allocate a token to the semaphore
            This will allow you to put an object back into the queue
            </summary>
            <returns>The object.</returns>
        </member>
        <member name="M:ThreadingUtilities.BoundChannel`1.Offer(System.Int32,`0)">
            <summary>
            Offer the specified TimeToWait and Object.
            
            This Method Accepts a Time to wait and the object that you want to put into the channel.
            This then once the Method is running checks if the Bound channel is full, Once it is full it will wait
            If the time waited is greater than the time spent in the channel, this will return False.
            </summary>
            <param name="TimeToWait">Time to wait.</param>
            <param name="Object">Object.</param>
        </member>
        <member name="T:ThreadingUtilities.Semaphore">
            <summary>
            Semaphore.
            
            THREAD ABORT IS NOT SUPPORTED
            THREAD PAUSE IS NOT SUPPORTED
            
            This code allows you to communicate to various threads and allowing access and releasing access to certain pieces of code
            In software, a semaphore is a data structure that is useful for solving a variety of synchronization problems.
            When a thread decrements the semaphore, if the result is negative, 
            the thread blocks itself and cannot continue until another thread increments the semaphore.
            When a thread increments the semaphore, if there are other threads wait- ing, one of the waiting threads gets unblocked
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Semaphore.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.Semaphore"/> class.
            
            Initialisation of the tokencount is here, for a Semaphore that you want to acquire some tokens without releasing, put the Number in.
            Once all released and token count = 0 this will wait for you to release more tokens to allow more threads to acquire.
            </summary>
            <param name="NumberOfTokens">Number of tokens.</param>
        </member>
        <member name="M:ThreadingUtilities.Semaphore.AcquireToken">
            <summary>
            Acquires the token.
            
            The thread blocks itself and cannot continue until another thread increments the semaphore.
            this is done by waiting for the token count to be more then one and once it is decreases the Token count.
            To Increment the Token count Please use the ReleaseToken() method of this class. If you need to release more then one 
            Put the number of tokens you want to release in the parameters
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Semaphore.ReleaseToken">
            <summary>
            Releases the token.
            
            This releases one token for the semaphore
            This also relies on the other overloaded release token method, more will be explained there.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Semaphore.ReleaseToken(System.UInt64)">
            <summary>
            Releases the token.
            
            This allows you to increment the tokens by the given number inputted, being TokensToRelease
            This will allow a token to be able to be released so a thread will be able to acquire it. 
            </summary>
            <param name="TokensToRelease">Tokens to release.</param>
        </member>
        <member name="M:ThreadingUtilities.Semaphore.ForceRelease(System.UInt64)">
            <summary>
            Forces the release.
            
            What this method tries to do is make an unbreakable way to release a set amount of tokens. this cannot be interuppted by the 
            ThreadInterruptedException, except it logs that this has happened and then
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Semaphore.TryAcquire(System.Int32)">
            <summary>
            Tries the acquire.
            
            What this Tries to do is sees it the token for the semaphore is available, if it is not however, it waits for the 
            Token to be available, This then waits for a specified amount of time, this is provided by the user as a integer field
            If it acquires the semaphore during this time it will return true to the calling method
            However if it times out of the acquire method it will return false to the user, signaling that the thread left while waiting
            
            </summary>
            <returns><c>true</c>, if acquire was sucessful, <c>false</c> otherwise.</returns>
            <param name="MSToWait">MS to wait.</param>
        </member>
        <member name="T:ThreadingUtilities.Mutex">
            <summary>
            Mutex.
            
            Mutex is an expansion of a Semapore, This new piece of data allows only one token to be ever present.
            this is done by limiting the Release token only to one token. 
            If you do try to release two tokens or send the release token method twice, it will error out
            Acquire token still works in the same vain as a Semaphore and a Mutex can be used as a Lock.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Mutex.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.Mutex"/> class.
            
            Initialises a new Mutex class and passes a variable to the inherited Semaphore class of 0 tokens. 
            This makes you release a token first to then let a thread / tool acquire it.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Mutex.ReleaseToken(System.UInt64)">
            <summary>
            Releases the token.
            
            This allows you to increment the tokens by ONE, If tokens release is more then one it will throw a ArgumentOutOfRangeException.
            This will allow a token to be able to be released so a thread will be able to acquire it.
            </summary>
            <param name="TokensToRelease">Tokens to release.</param>
        </member>
        <member name="T:ThreadingUtilities.Latch">
            <summary>
            Latch.
            
            Latch basically allows you to hold a line of threads until you want to release then at a certain point to continue their work.
            This uses a semaphore that allows you to wait until a point where you want to open the door.
            The threads wait at the get through method until you open the door, this allows every thread through.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Latch.#ctor">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.Latch"/> class.
            
            This allows the creation of the Latch and the semaphore that is within the latch, 
            The semaphore will take a argument of 0, this will allow to the open door method to be effective.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Latch.GetThrough">
            <summary>
            Get through Method.
            
            This is the main method of the Latch, this will allow the thread to wait at this point. 
            Untill you add a token to the semaphore this will not allow you to pass.
            This is effective when you want to wait until a task is completed then let threads go though to another stage.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Latch.OpenDoor">
            <summary>
            Opens the door.
            
            This is the allowing method for this class, this will allow a method or thread to trip this and allow every thread through
            This releases a token to the semaphore and since the GoThrough method is waiting for a token, this will instantaniously let it though
            </summary>
        </member>
        <member name="T:ThreadingUtilities.Lightswitch">
            <summary>
            Lightswitch.
            
            Lightswitch class allows you to have the ability to let multiple threads go to a task without assigning multiple tokens
            this means one token can have more then one thread working on somthing.
            
            this works on the premace that you will pass in a semaphore of your choice to handle the requests
            This lightswitch everytime it will take a token will allow multiple threads WITH REFRENCE TO THE LIGHTSWITCH to enter
            Once all the threads have done what they need to do, they will exit and return the token that they consumed.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Lightswitch.#ctor(ThreadingUtilities.Semaphore)">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.Lightswitch"/> class.
            
            This allows the creation of the Lightswitch, this accepts a Semaphore as a paramater and only allows this to be passed in
            this is detrement to what you want to do, make sure you pick the right semaphore to pass in. 
            </summary>
            <param name="LightswitchSemaphore">Lightswitch semaphore.</param>
        </member>
        <member name="M:ThreadingUtilities.Lightswitch.Acquire">
            <summary>
            Acquire this instance.
            
            This is the Acquire method for the Lightswitch
            This will allow multiple threads to go in with only one token. This is done by the first thread acquiring and then the others going in after
            This is possible by using an other variable to keep track of the threads coming in.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Lightswitch.Release">
            <summary>
            Release this instance.
            
            This is the release method for the lightswitch
            This will allow threads to leave the lightswitch without giving up the token. This is only possible when checking if there are still threads 
            being exicuted. after the last thread leaves, the Lightswitch will give up the token.
            </summary>
        </member>
        <member name="T:ThreadingUtilities.ReaderWriter">
            <summary>
            Reader writer.
            
            This class Solves a fequent problem with databases in mind. 
            This allows you to read multiple times with a lightswitch and allows you to write using the semaphore token.
            This means you can have multiple reads going on at a time and only one write at a time.
            This allows us to keep the integrety of the data.
            
            This also has some fixes to this problem, there will be a number of reads that will be able to go through and when there is a write, it allows it through
            this is by using turnstyles to allow this through.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.ReaderWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.ReaderWriter"/> class.
            
            This Initializes the Reader Writer. All this will do is Initialize all of the global variables for the class to work.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.ReaderWriter.ReadAcquire">
            <summary>
            Read Acquire Method.
            
            This allows you to acquire the token for the intent of READING only. 
            This works by using a lightswitch and allows to pass multiple threads for the price of only one token.
            
            This will hold onto the token until a point where the Writer has the ReaderBlock token, otherwise will keep on reading
            </summary>
        </member>
        <member name="M:ThreadingUtilities.ReaderWriter.ReadRelease">
            <summary>
            Read Release Method.
            
            This allows you to release the thread from the pool of threads.
            This will use the method in Lightswitch.Release to handle this request.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.ReaderWriter.WriterAcquire">
            <summary>
            Writer Acquire Method.
            
            Writer acquire will be used for WRITING only this is designed only to have this go through at a time.
            This works by using the full semaphore as the way of letting in the token.
            
            Once the thread has started in the methd it will make sure that no Readers can interuppt and allow it to write safely.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.ReaderWriter.WriteRelease">
            <summary>
            Write release for Writing to a source.
            
            This allows you to release the thread from the one Thread.
            This will use the method in the Semaphore.Release to handle this request.
            </summary>
        </member>
        <member name="T:ThreadingUtilities.Barrier">
            <summary>
            Barrier.
            
            Barrier's allow you to specify a number and this number is the amount of threads allowed through
            This works by using two different turnstyles and allows a number of threads to enter, and once it reaches the number, goes through the Second.
            Turnstyle. This makes sure that the number of threads that have been specified is the number that exits.
            This will provide an output in a boolean state.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Barrier.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.Barrier"/> class.
            
            This is the constructor for the Barrier class, This accepts a uLong as the limit to the barrier
            Please take note this will be the limit of the Threads that you want to go through at a time.
            </summary>
            <param name="Limit">Limit.</param>
        </member>
        <member name="M:ThreadingUtilities.Barrier.Arrive">
            <summary>
            Arrive this instance.
            
            This is the Main method of the Barrier class. 
            This uses the two Turnstyles to get the desired result. It also returns a boolean result of the thread that set the start of the process.
            
            The main difference is that the first turnstyle counts till the limit and sets the result area
            Once it reaches the Boolean value it fires off the second turnstyle. to make sure that there are no other threads entering and throwing out the 
            balance. once it reaches this it returns the boolean value.
            </summary>
        </member>
        <member name="T:ThreadingUtilities.FifoSemaphore">
            <summary>
            Fifo semaphore.
            
            FIFO semaphore allows a First in First out queue senario. This Backs of the Semaphore class however has the extra security of being first in first out
            this is achieved by using a number as the declaration of the thread trying to access the semaphore
            This allows the first in and first out senario
            </summary>
        </member>
        <member name="M:ThreadingUtilities.FifoSemaphore.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.FifoSemaphore"/> class.
            
            This accepts a ulong number as the number of tokens that are in the base semaphore class so you can then create the FIFO semaphore 
            With the amount of desired tokens. This Constructor also creates the ulongs for the threadcount and the ThreadNumber 
            </summary>
            <param name="NumberOfTokens">Number of tokens.</param>
        </member>
        <member name="M:ThreadingUtilities.FifoSemaphore.AcquireToken">
            <summary>
            Acquires the token.
            
            The thread blocks itself and cannot continue until another thread increments the semaphore.
            this is done by waiting for the token count to be more then one and once it is decreases the Token count.
            To Increment the Token count Please use the ReleaseToken() method of this class. If you need to release more then
            one 
            Put the number of tokens you want to release in the parameters
            
            This Method also allows the FIFO technology, 
            </summary>
        </member>
        <member name="T:ThreadingUtilities.Exchange`1">
            <summary>
            Exchange.
            
            This code allows you to exchange objects between threads safely without the need of a channel or a bound channel.
            What you will need to do is make sure that you declare the Exchange to the type that you need and
            Then use the Exchange method to exchnge data between threads. This Exchange method is re-useable and accepts two threads at a time
            After the data exchanges it will accept another two threads to exchange.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Exchange`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="!:Mark.Utilities.MAC.Exchange`1"/> class.
            
            Initializes the Semaphores that are used in the Exchange there is no Passed in variables so it is able to be called and used instantly.
            </summary>
        </member>
        <member name="M:ThreadingUtilities.Exchange`1.ExchangeItem(`0)">
            <summary>
            Exchange the specified Object.
            
            This Method is where all the work happends, This will only accept two threads at a time and until the process is complete and returning data
            it will halt all of the threads that enter the Method, This Will then allow one thread to check if there is data and if there isnt add data
            This will then signal the second thread to start. This will then run the check for the data, But there is some due to the first thread.
            This will then Take that data deposited into a new variable so it can be cleared before it returns. And then reset the semaphores to accept 
            Another two threads. The last being the semaphore that is blocking the two threads.
            </summary>
            <param name="Object">Object.</param>
        </member>
    </members>
</doc>
